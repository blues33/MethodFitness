<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: eventStoreConnection.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: eventStoreConnection.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var EventStoreNodeConnection = require('./eventStoreNodeConnection');
var StaticEndpointDiscoverer = require('./core/staticEndpointDiscoverer');
var ClusterDnsEndPointDiscoverer = require('./core/clusterDnsEndPointDiscoverer');
var NoopLogger = require('./common/log/noopLogger');
var ensure = require('./common/utils/ensure');

var defaultConnectionSettings = {
  log: new NoopLogger(),
  verboseLogging: false,

  maxQueueSize: 5000,
  maxConcurrentItems: 5000,
  maxRetries: 10,
  maxReconnections: 10,

  requireMaster: true,

  reconnectionDelay: 100,
  operationTimeout: 7*1000,
  operationTimeoutCheckPeriod: 1000,

  defaultUserCredentials: null,
  useSslConnection: false,
  targetHost: null,
  validateServer: false,

  failOnNoServerResponse: false,
  heartbeatInterval: 750,
  heartbeatTimeout: 1500,
  clientConnectionTimeout: 1000,

  // Cluster Settings
  clusterDns: '',
  maxDiscoverAttempts: 10,
  externalGossipPort: 0,
  gossipTimeout: 1000
};


function merge(a,b) {
  var c = {};
  Object.getOwnPropertyNames(a).forEach(function(k) {
    c[k] = a[k];
  });
  Object.getOwnPropertyNames(b).forEach(function(k) {
    c[k] = b[k];
  });
  return c;
}

function createFromTcpEndpoint(settings, tcpEndpoint, connectionName) {
  if (!tcpEndpoint.port || !tcpEndpoint.host) throw new TypeError('endPoint object must have host and port properties.');
  var mergedSettings = merge(defaultConnectionSettings, settings || {});
  var endpointDiscoverer = new StaticEndpointDiscoverer(tcpEndpoint, settings.useSslConnection);
  return new EventStoreNodeConnection(mergedSettings, null, endpointDiscoverer, connectionName || null);
}

function createFromStringEndpoint(settings, endPoint, connectionName) {
  var m = endPoint.match(/^(tcp|discover):\/\/([^:]+):?(\d+)?$/);
  if (!m) throw new Error('endPoint string must be tcp://hostname[:port] or discover://dns[:port]');
  var scheme = m[1];
  var host = m[2] || null;
  var port = m[3] ? parseInt(m[3]) : null;
  if (scheme === 'tcp') {
    var tcpEndpoint = {
      host: host,
      port: port || 1113
    };
    return createFromTcpEndpoint(settings, tcpEndpoint, connectionName);
  }
  if (scheme === 'discover') {
    return createFromClusterDns(settings, host, port || 2113, connectionName);
  }
  throw new Error('Invalid scheme for endPoint: ' + scheme);
}

function createFromClusterDns(connectionSettings, clusterDns, externalGossipPort, connectionName) {
  ensure.notNull(connectionSettings, "connectionSettings");
  ensure.notNull(clusterDns, "clusterDns");
  var mergedSettings = merge(defaultConnectionSettings, connectionSettings || {});
  var clusterSettings = {
    clusterDns: clusterDns,
    gossipSeeds: null,
    externalGossipPort: externalGossipPort,
    maxDiscoverAttempts: mergedSettings.maxDiscoverAttempts,
    gossipTimeout: mergedSettings.gossipTimeout
  };
  var endPointDiscoverer = new ClusterDnsEndPointDiscoverer(mergedSettings.log,
    clusterSettings.clusterDns,
    clusterSettings.maxDiscoverAttempts,
    clusterSettings.externalGossipPort,
    clusterSettings.gossipSeeds,
    clusterSettings.gossipTimeout
  );
  return new EventStoreNodeConnection(mergedSettings, clusterSettings, endPointDiscoverer, connectionName);
}

function createFromGossipSeeds(connectionSettings, gossipSeeds, connectionName) {
  ensure.notNull(connectionSettings, "connectionSettings");
  ensure.notNull(gossipSeeds, "gossipSeeds");
  var mergedSettings = merge(defaultConnectionSettings, connectionSettings || {});
  var clusterSettings = {
    clusterDns: '',
    gossipSeeds: gossipSeeds,
    externalGossipPort: 0,
    maxDiscoverAttempts: mergedSettings.maxDiscoverAttempts,
    gossipTimeout: mergedSettings.gossipTimeout
  };
  var endPointDiscoverer = new ClusterDnsEndPointDiscoverer(mergedSettings.log,
    clusterSettings.clusterDns,
    clusterSettings.maxDiscoverAttempts,
    clusterSettings.externalGossipPort,
    clusterSettings.gossipSeeds,
    clusterSettings.gossipTimeout
  );
  return new EventStoreNodeConnection(mergedSettings, clusterSettings, endPointDiscoverer, connectionName);
}

/**
 * Create an EventStore connection
 * @public
 * @alias createConnection
 * @param {object} settings
 * @param {string|object|array} endPointOrGossipSeeds
 * @param {string} [connectionName]
 * @returns {EventStoreNodeConnection}
 */
module.exports.create = function(settings, endPointOrGossipSeeds, connectionName) {
  if (Array.isArray(endPointOrGossipSeeds)) return createFromGossipSeeds(settings, endPointOrGossipSeeds, connectionName);
  if (typeof endPointOrGossipSeeds === 'object') return createFromTcpEndpoint(settings, endPointOrGossipSeeds, connectionName);
  if (typeof endPointOrGossipSeeds === 'string') return createFromStringEndpoint(settings, endPointOrGossipSeeds, connectionName);
  throw new TypeError('endPointOrGossipSeeds must be an object, a string or an array.');
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AllEventsSlice.html">AllEventsSlice</a></li><li><a href="DeleteResult.html">DeleteResult</a></li><li><a href="EventReadResult.html">EventReadResult</a></li><li><a href="EventStoreCatchUpSubscription.html">EventStoreCatchUpSubscription</a></li><li><a href="EventStoreNodeConnection.html">EventStoreNodeConnection</a></li><li><a href="EventStoreTransaction.html">EventStoreTransaction</a></li><li><a href="PersistentSubscriptionCreateResult.html">PersistentSubscriptionCreateResult</a></li><li><a href="PersistentSubscriptionDeleteResult.html">PersistentSubscriptionDeleteResult</a></li><li><a href="PersistentSubscriptionUpdateResult.html">PersistentSubscriptionUpdateResult</a></li><li><a href="Position.html">Position</a></li><li><a href="RawStreamMetadataResult.html">RawStreamMetadataResult</a></li><li><a href="RecordedEvent.html">RecordedEvent</a></li><li><a href="ResolvedEvent.html">ResolvedEvent</a></li><li><a href="StreamEventsSlice.html">StreamEventsSlice</a></li><li><a href="UserCredentials.html">UserCredentials</a></li><li><a href="WriteResult.html">WriteResult</a></li></ul><h3>Global</h3><ul><li><a href="global.html#createConnection">createConnection</a></li><li><a href="global.html#createEventData">createEventData</a></li><li><a href="global.html#createJsonEventData">createJsonEventData</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Wed Mar 08 2017 15:08:29 GMT-0800 (PST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
